# üéØ Saga Pattern (Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò)

## üìñ Saga PatternÏù¥ÎûÄ?

SagaÎäî **ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ ÌôòÍ≤ΩÏóêÏÑú Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖòÏùÑ Í¥ÄÎ¶¨**ÌïòÎäî Ìå®ÌÑ¥ÏûÖÎãàÎã§.  
Í∏¥ Ìä∏ÎûúÏû≠ÏÖòÏùÑ Ïó¨Îü¨ Í∞úÏùò Î°úÏª¨ Ìä∏ÎûúÏû≠ÏÖòÏúºÎ°ú ÎÇòÎàÑÍ≥†, Ïã§Ìå® Ïãú Î≥¥ÏÉÅ Ìä∏ÎûúÏû≠ÏÖòÏúºÎ°ú Î°§Î∞±Ìï©ÎãàÎã§.

### Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖòÏùò Î¨∏Ï†ú

```
Í∏∞Ï°¥ 2PC (Two-Phase Commit):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  Prepare  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  TM  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ DB1  ‚îÇ
‚îÇ      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      ‚îÇ
‚îÇ      ‚îÇ  Ready    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ      ‚îÇ  Prepare  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ DB2  ‚îÇ
‚îÇ      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  Ready    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ
    ‚îî‚îÄ Commit All or Rollback All

Î¨∏Ï†úÏ†ê:
- ÎèôÍ∏∞Ïãù Î∏îÎ°úÌÇπ
- Îã®Ïùº Ïã§Ìå® ÏßÄÏ†ê
- ÏÑ±Îä• Ï†ÄÌïò
- ÌôïÏû•ÏÑ± Ï†úÌïú
```

## üèóÔ∏è Saga Ìå®ÌÑ¥ Ï¢ÖÎ•ò

### 1. Choreography (ÏïàÎ¨¥) Î∞©Ïãù

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê Event ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê Event ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇService A‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇService B‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇService C‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚ñ≤                                    ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              Compensation Event
```

### 2. Orchestration (Ïò§ÏºÄÏä§Ìä∏Î†àÏù¥ÏÖò) Î∞©Ïãù

```
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇSaga Manager  ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚ñº         ‚ñº         ‚ñº
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇService ‚îÇ‚îÇService ‚îÇ‚îÇService ‚îÇ
   ‚îÇ   A    ‚îÇ‚îÇ   B    ‚îÇ‚îÇ   C    ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üíª Íµ¨ÌòÑ ÏòàÏ†ú - Ï£ºÎ¨∏ Ï≤òÎ¶¨ Saga

### ÏãúÎÇòÎ¶¨Ïò§: Ïò®ÎùºÏù∏ ÏáºÌïëÎ™∞ Ï£ºÎ¨∏ Ï≤òÎ¶¨

```
1. Ï£ºÎ¨∏ ÏÉùÏÑ± (Order Service)
2. Í≤∞Ï†ú Ï≤òÎ¶¨ (Payment Service)
3. Ïû¨Í≥† Ï∞®Í∞ê (Inventory Service)
4. Î∞∞ÏÜ° Ï§ÄÎπÑ (Shipping Service)

Ïã§Ìå® Ïãú Ïó≠ÏàúÏúºÎ°ú Î≥¥ÏÉÅ:
4. Î∞∞ÏÜ° Ï∑®ÏÜå
3. Ïû¨Í≥† Î≥µÍµ¨
2. Í≤∞Ï†ú Ï∑®ÏÜå
1. Ï£ºÎ¨∏ Ï∑®ÏÜå
```

### 1. Choreography Î∞©Ïãù Íµ¨ÌòÑ

```javascript
// Order Service
class OrderService {
  constructor() {
    this.kafka = new Kafka({
      clientId: 'order-service',
      brokers: ['localhost:9092']
    })
    this.producer = this.kafka.producer()
    this.consumer = this.kafka.consumer({ groupId: 'order-group' })
  }
  
  async createOrder(orderData) {
    try {
      // 1. Ï£ºÎ¨∏ ÏÉùÏÑ±
      const order = {
        orderId: uuidv4(),
        userId: orderData.userId,
        items: orderData.items,
        totalAmount: orderData.totalAmount,
        status: 'PENDING',
        createdAt: new Date()
      }
      
      await this.saveOrder(order)
      
      // 2. Ï£ºÎ¨∏ ÏÉùÏÑ± Ïù¥Î≤§Ìä∏ Î∞úÌñâ
      await this.publishEvent({
        type: 'ORDER_CREATED',
        orderId: order.orderId,
        userId: order.userId,
        amount: order.totalAmount,
        items: order.items
      })
      
      return order
    } catch (error) {
      console.error('Order creation failed:', error)
      throw error
    }
  }
  
  async startEventListener() {
    await this.consumer.subscribe({
      topics: ['payment-events', 'inventory-events', 'shipping-events']
    })
    
    await this.consumer.run({
      eachMessage: async ({ topic, message }) => {
        const event = JSON.parse(message.value)
        await this.handleEvent(event)
      }
    })
  }
  
  async handleEvent(event) {
    switch(event.type) {
      case 'PAYMENT_COMPLETED':
        await this.handlePaymentCompleted(event)
        break
      case 'PAYMENT_FAILED':
        await this.handlePaymentFailed(event)
        break
      case 'INVENTORY_RESERVED':
        await this.handleInventoryReserved(event)
        break
      case 'INVENTORY_INSUFFICIENT':
        await this.handleInventoryInsufficient(event)
        break
      case 'SHIPPING_PREPARED':
        await this.handleShippingPrepared(event)
        break
      case 'SHIPPING_FAILED':
        await this.handleShippingFailed(event)
        break
    }
  }
  
  async handlePaymentFailed(event) {
    // Î≥¥ÏÉÅ Ìä∏ÎûúÏû≠ÏÖò: Ï£ºÎ¨∏ Ï∑®ÏÜå
    await this.updateOrderStatus(event.orderId, 'CANCELLED')
    
    await this.publishEvent({
      type: 'ORDER_CANCELLED',
      orderId: event.orderId,
      reason: 'Payment failed'
    })
  }
  
  async publishEvent(event) {
    await this.producer.send({
      topic: 'order-events',
      messages: [{
        key: event.orderId,
        value: JSON.stringify(event)
      }]
    })
  }
}

// Payment Service
class PaymentService {
  constructor() {
    this.kafka = new Kafka({
      clientId: 'payment-service',
      brokers: ['localhost:9092']
    })
    this.producer = this.kafka.producer()
    this.consumer = this.kafka.consumer({ groupId: 'payment-group' })
  }
  
  async startEventListener() {
    await this.consumer.subscribe({
      topics: ['order-events', 'inventory-events']
    })
    
    await this.consumer.run({
      eachMessage: async ({ message }) => {
        const event = JSON.parse(message.value)
        await this.handleEvent(event)
      }
    })
  }
  
  async handleEvent(event) {
    switch(event.type) {
      case 'ORDER_CREATED':
        await this.processPayment(event)
        break
      case 'INVENTORY_INSUFFICIENT':
        await this.refundPayment(event)
        break
      case 'SHIPPING_FAILED':
        await this.refundPayment(event)
        break
    }
  }
  
  async processPayment(orderEvent) {
    try {
      // Í≤∞Ï†ú Ï≤òÎ¶¨ Î°úÏßÅ
      const payment = {
        paymentId: uuidv4(),
        orderId: orderEvent.orderId,
        amount: orderEvent.amount,
        status: 'PROCESSING'
      }
      
      // Ïô∏Î∂Ä Í≤∞Ï†ú Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Ìò∏Ï∂ú
      const result = await this.callPaymentGateway(payment)
      
      if (result.success) {
        payment.status = 'COMPLETED'
        await this.savePayment(payment)
        
        await this.publishEvent({
          type: 'PAYMENT_COMPLETED',
          orderId: orderEvent.orderId,
          paymentId: payment.paymentId,
          amount: payment.amount
        })
      } else {
        throw new Error('Payment failed')
      }
    } catch (error) {
      console.error('Payment failed:', error)
      
      await this.publishEvent({
        type: 'PAYMENT_FAILED',
        orderId: orderEvent.orderId,
        reason: error.message
      })
    }
  }
  
  async refundPayment(event) {
    // Î≥¥ÏÉÅ Ìä∏ÎûúÏû≠ÏÖò: Í≤∞Ï†ú Ï∑®ÏÜå
    const payment = await this.findPaymentByOrderId(event.orderId)
    if (payment && payment.status === 'COMPLETED') {
      await this.callRefundGateway(payment)
      
      await this.updatePaymentStatus(payment.paymentId, 'REFUNDED')
      
      await this.publishEvent({
        type: 'PAYMENT_REFUNDED',
        orderId: event.orderId,
        paymentId: payment.paymentId,
        amount: payment.amount
      })
    }
  }
}

// Inventory Service
class InventoryService {
  constructor() {
    this.kafka = new Kafka({
      clientId: 'inventory-service',
      brokers: ['localhost:9092']
    })
  }
  
  async handleEvent(event) {
    switch(event.type) {
      case 'PAYMENT_COMPLETED':
        await this.reserveInventory(event)
        break
      case 'SHIPPING_FAILED':
        await this.releaseInventory(event)
        break
      case 'ORDER_CANCELLED':
        await this.releaseInventory(event)
        break
    }
  }
  
  async reserveInventory(event) {
    try {
      const reservations = []
      
      for (const item of event.items) {
        const stock = await this.checkStock(item.productId)
        
        if (stock < item.quantity) {
          // Ïû¨Í≥† Î∂ÄÏ°± - Ïù¥ÎØ∏ ÏòàÏïΩÎêú Í≤ÉÎì§ Î°§Î∞±
          for (const reservation of reservations) {
            await this.releaseStock(reservation.productId, reservation.quantity)
          }
          
          throw new Error(`Insufficient stock for ${item.productId}`)
        }
        
        await this.decrementStock(item.productId, item.quantity)
        reservations.push(item)
      }
      
      await this.publishEvent({
        type: 'INVENTORY_RESERVED',
        orderId: event.orderId,
        items: reservations
      })
    } catch (error) {
      await this.publishEvent({
        type: 'INVENTORY_INSUFFICIENT',
        orderId: event.orderId,
        reason: error.message
      })
    }
  }
  
  async releaseInventory(event) {
    // Î≥¥ÏÉÅ Ìä∏ÎûúÏû≠ÏÖò: Ïû¨Í≥† Î≥µÍµ¨
    for (const item of event.items) {
      await this.incrementStock(item.productId, item.quantity)
    }
    
    await this.publishEvent({
      type: 'INVENTORY_RELEASED',
      orderId: event.orderId
    })
  }
}
```

### 2. Orchestration Î∞©Ïãù Íµ¨ÌòÑ

```javascript
// Saga Orchestrator
class OrderSagaOrchestrator {
  constructor() {
    this.kafka = new Kafka({
      clientId: 'saga-orchestrator',
      brokers: ['localhost:9092']
    })
    this.producer = this.kafka.producer()
    this.consumer = this.kafka.consumer({ groupId: 'saga-group' })
    
    // Saga ÏÉÅÌÉú Ï†ÄÏû•ÏÜå
    this.sagaStore = new Map()
  }
  
  async startSaga(orderData) {
    const sagaId = uuidv4()
    const saga = {
      sagaId,
      orderId: orderData.orderId,
      status: 'STARTED',
      steps: [],
      currentStep: 0,
      data: orderData
    }
    
    this.sagaStore.set(sagaId, saga)
    
    // Saga Ïã§Ìñâ
    await this.executeNextStep(saga)
    
    return sagaId
  }
  
  async executeNextStep(saga) {
    const steps = [
      { name: 'CREATE_ORDER', service: 'order-service', command: 'CreateOrder' },
      { name: 'PROCESS_PAYMENT', service: 'payment-service', command: 'ProcessPayment' },
      { name: 'RESERVE_INVENTORY', service: 'inventory-service', command: 'ReserveInventory' },
      { name: 'PREPARE_SHIPPING', service: 'shipping-service', command: 'PrepareShipping' }
    ]
    
    if (saga.currentStep >= steps.length) {
      // Saga ÏôÑÎ£å
      saga.status = 'COMPLETED'
      await this.publishEvent({
        type: 'SAGA_COMPLETED',
        sagaId: saga.sagaId,
        orderId: saga.orderId
      })
      return
    }
    
    const currentStep = steps[saga.currentStep]
    
    // Ïª§Îß®Îìú Ï†ÑÏÜ°
    await this.sendCommand({
      sagaId: saga.sagaId,
      step: currentStep.name,
      service: currentStep.service,
      command: currentStep.command,
      data: saga.data
    })
    
    // ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
    this.setStepTimeout(saga.sagaId, currentStep.name, 30000)
  }
  
  async handleReply(reply) {
    const saga = this.sagaStore.get(reply.sagaId)
    if (!saga) return
    
    if (reply.status === 'SUCCESS') {
      // ÏÑ±Í≥µ - Îã§Ïùå Îã®Í≥Ñ ÏßÑÌñâ
      saga.steps.push({
        name: reply.step,
        status: 'COMPLETED',
        result: reply.result
      })
      saga.currentStep++
      
      await this.executeNextStep(saga)
    } else {
      // Ïã§Ìå® - Î≥¥ÏÉÅ Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
      saga.status = 'COMPENSATING'
      await this.startCompensation(saga)
    }
  }
  
  async startCompensation(saga) {
    console.log(`üîÑ Starting compensation for saga ${saga.sagaId}`)
    
    // ÏôÑÎ£åÎêú Îã®Í≥ÑÎì§ÏùÑ Ïó≠ÏàúÏúºÎ°ú Î≥¥ÏÉÅ
    const compensationSteps = [
      { step: 'PREPARE_SHIPPING', command: 'CancelShipping' },
      { step: 'RESERVE_INVENTORY', command: 'ReleaseInventory' },
      { step: 'PROCESS_PAYMENT', command: 'RefundPayment' },
      { step: 'CREATE_ORDER', command: 'CancelOrder' }
    ]
    
    for (const step of saga.steps.reverse()) {
      const compensation = compensationSteps.find(c => c.step === step.name)
      if (compensation) {
        await this.sendCompensationCommand({
          sagaId: saga.sagaId,
          step: compensation.step,
          command: compensation.command,
          data: step.result
        })
        
        // Î≥¥ÏÉÅ ÏôÑÎ£å ÎåÄÍ∏∞
        await this.waitForCompensation(saga.sagaId, compensation.step)
      }
    }
    
    saga.status = 'COMPENSATED'
    await this.publishEvent({
      type: 'SAGA_COMPENSATED',
      sagaId: saga.sagaId,
      orderId: saga.orderId
    })
  }
  
  async sendCommand(command) {
    await this.producer.send({
      topic: `${command.service}-commands`,
      messages: [{
        key: command.sagaId,
        value: JSON.stringify(command)
      }]
    })
  }
  
  async sendCompensationCommand(command) {
    await this.producer.send({
      topic: 'compensation-commands',
      messages: [{
        key: command.sagaId,
        value: JSON.stringify(command)
      }]
    })
  }
  
  setStepTimeout(sagaId, step, timeout) {
    setTimeout(async () => {
      const saga = this.sagaStore.get(sagaId)
      if (saga && saga.status === 'STARTED') {
        console.error(`‚è∞ Timeout for step ${step}`)
        saga.status = 'TIMEOUT'
        await this.startCompensation(saga)
      }
    }, timeout)
  }
}

// Saga Step Handler (Í∞Å ÏÑúÎπÑÏä§ÏóêÏÑú Íµ¨ÌòÑ)
class SagaStepHandler {
  constructor(serviceName) {
    this.serviceName = serviceName
    this.kafka = new Kafka({
      clientId: serviceName,
      brokers: ['localhost:9092']
    })
  }
  
  async start() {
    const consumer = this.kafka.consumer({ 
      groupId: `${this.serviceName}-saga-group` 
    })
    
    await consumer.subscribe({
      topics: [`${this.serviceName}-commands`, 'compensation-commands']
    })
    
    await consumer.run({
      eachMessage: async ({ message }) => {
        const command = JSON.parse(message.value)
        await this.handleCommand(command)
      }
    })
  }
  
  async handleCommand(command) {
    console.log(`üì• ${this.serviceName} received command:`, command.command)
    
    try {
      let result
      
      // ÏÑúÎπÑÏä§Î≥Ñ Ïª§Îß®Îìú Ï≤òÎ¶¨
      switch(command.command) {
        case 'CreateOrder':
          result = await this.createOrder(command.data)
          break
        case 'ProcessPayment':
          result = await this.processPayment(command.data)
          break
        case 'ReserveInventory':
          result = await this.reserveInventory(command.data)
          break
        case 'PrepareShipping':
          result = await this.prepareShipping(command.data)
          break
        // Î≥¥ÏÉÅ Ïª§Îß®Îìú
        case 'CancelOrder':
          result = await this.cancelOrder(command.data)
          break
        case 'RefundPayment':
          result = await this.refundPayment(command.data)
          break
        case 'ReleaseInventory':
          result = await this.releaseInventory(command.data)
          break
        case 'CancelShipping':
          result = await this.cancelShipping(command.data)
          break
      }
      
      // ÏÑ±Í≥µ ÏùëÎãµ
      await this.sendReply({
        sagaId: command.sagaId,
        step: command.step,
        status: 'SUCCESS',
        result: result
      })
    } catch (error) {
      // Ïã§Ìå® ÏùëÎãµ
      await this.sendReply({
        sagaId: command.sagaId,
        step: command.step,
        status: 'FAILED',
        error: error.message
      })
    }
  }
  
  async sendReply(reply) {
    const producer = this.kafka.producer()
    await producer.connect()
    
    await producer.send({
      topic: 'saga-replies',
      messages: [{
        key: reply.sagaId,
        value: JSON.stringify(reply)
      }]
    })
    
    await producer.disconnect()
  }
}
```

### 3. Saga ÏÉÅÌÉú Í¥ÄÎ¶¨

```javascript
// Saga State Machine
class SagaStateMachine {
  constructor(sagaId) {
    this.sagaId = sagaId
    this.state = 'INITIAL'
    this.transitions = {
      INITIAL: {
        START: 'EXECUTING'
      },
      EXECUTING: {
        SUCCESS: 'EXECUTING',
        COMPLETE: 'COMPLETED',
        FAIL: 'COMPENSATING',
        TIMEOUT: 'COMPENSATING'
      },
      COMPENSATING: {
        COMPENSATE_SUCCESS: 'COMPENSATING',
        COMPENSATE_COMPLETE: 'COMPENSATED',
        COMPENSATE_FAIL: 'FAILED'
      },
      COMPLETED: {},
      COMPENSATED: {},
      FAILED: {}
    }
  }
  
  transition(event) {
    const currentTransitions = this.transitions[this.state]
    const nextState = currentTransitions[event]
    
    if (!nextState) {
      throw new Error(`Invalid transition: ${this.state} -> ${event}`)
    }
    
    console.log(`üîÑ Saga ${this.sagaId}: ${this.state} -> ${nextState}`)
    this.state = nextState
    
    return nextState
  }
  
  isTerminal() {
    return ['COMPLETED', 'COMPENSATED', 'FAILED'].includes(this.state)
  }
  
  canCompensate() {
    return this.state === 'COMPENSATING'
  }
}

// Saga Log Store (Event Sourcing)
class SagaLogStore {
  constructor() {
    this.logs = new Map()
  }
  
  async append(sagaId, event) {
    if (!this.logs.has(sagaId)) {
      this.logs.set(sagaId, [])
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      event: event,
      sequence: this.logs.get(sagaId).length
    }
    
    this.logs.get(sagaId).push(logEntry)
    
    // KafkaÏóê ÏòÅÍµ¨ Ï†ÄÏû•
    await this.persistToKafka(sagaId, logEntry)
  }
  
  async persistToKafka(sagaId, logEntry) {
    const producer = kafka.producer()
    await producer.send({
      topic: 'saga-logs',
      messages: [{
        key: sagaId,
        value: JSON.stringify(logEntry)
      }]
    })
  }
  
  async recover(sagaId) {
    // KafkaÏóêÏÑú Î°úÍ∑∏ Î≥µÏõê
    const logs = await this.loadFromKafka(sagaId)
    const saga = this.replayLogs(logs)
    return saga
  }
  
  replayLogs(logs) {
    const saga = new SagaStateMachine(logs[0].sagaId)
    
    for (const log of logs) {
      // Ïù¥Î≤§Ìä∏ Ïû¨Ïã§ÌñâÏúºÎ°ú ÏÉÅÌÉú Î≥µÏõê
      saga.transition(log.event.type)
    }
    
    return saga
  }
}
```

## üìä Ïû•Îã®Ï†ê

### Ïû•Ï†ê ‚úÖ
- **ÎäêÏä®Ìïú Í≤∞Ìï©**: ÏÑúÎπÑÏä§ Í∞Ñ ÎèÖÎ¶ΩÏÑ± Ïú†ÏßÄ
- **Î∂ÄÎ∂Ñ Ïã§Ìå® Ï≤òÎ¶¨**: Ïã§Ìå®Ìïú Î∂ÄÎ∂ÑÎßå Î°§Î∞±
- **ÌôïÏû•ÏÑ±**: ÏÑúÎπÑÏä§Î≥Ñ ÎèÖÎ¶ΩÏ†Å ÌôïÏû•
- **Í∞ÄÏãúÏÑ±**: Ìä∏ÎûúÏû≠ÏÖò ÏÉÅÌÉú Ï∂îÏ†Å Í∞ÄÎä•

### Îã®Ï†ê ‚ùå
- **Î≥µÏû°ÏÑ±**: Íµ¨ÌòÑ Î∞è ÎîîÎ≤ÑÍπÖ Ïñ¥Î†§ÏõÄ
- **ÏµúÏ¢Ö ÏùºÍ¥ÄÏÑ±**: Ï¶âÏãú ÏùºÍ¥ÄÏÑ± Î≥¥Ïû• ÏïàÎê®
- **Î≥¥ÏÉÅ Î°úÏßÅ**: Î™®Îì† ÏûëÏóÖÏóê Î≥¥ÏÉÅ Î°úÏßÅ ÌïÑÏöî
- **ÌÖåÏä§Ìä∏ Ïñ¥Î†§ÏõÄ**: Î∂ÑÏÇ∞ ÏãúÎÇòÎ¶¨Ïò§ ÌÖåÏä§Ìä∏ Î≥µÏû°

## üîç Best Practices

1. **Î©±Îì±ÏÑ± Î≥¥Ïû•**: Ïû¨ÏãúÎèÑ Ïãú Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ
2. **ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï**: Í∞Å Îã®Í≥ÑÎ≥Ñ ÌÉÄÏûÑÏïÑÏõÉ ÌïÑÏàò
3. **Î°úÍπÖ**: Î™®Îì† Îã®Í≥Ñ ÏÉÅÏÑ∏ Î°úÍπÖ
4. **Î™®ÎãàÌÑ∞ÎßÅ**: Saga ÏÉÅÌÉú Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ
5. **Î≥¥ÏÉÅ ÏÑ§Í≥Ñ**: Ïã§Ìå® ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ Î≥¥ÏÉÅ Ï†ÑÎûµ
6. **ÌÖåÏä§Ìä∏**: Ïã§Ìå® ÏãúÎÇòÎ¶¨Ïò§ Ï∂©Î∂ÑÌïú ÌÖåÏä§Ìä∏

---

üí° **Í¥ÄÎ†® Ìå®ÌÑ¥**: [Event Sourcing](./event-sourcing.md), [CQRS](./cqrs.md)