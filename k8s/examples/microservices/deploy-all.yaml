# Microservices E-Commerce Platform - Complete Deployment
---
# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: microservices

---
# ============================================
# Infrastructure Services
# ============================================

# PostgreSQL for User Service
---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-users-secret
  namespace: microservices
type: Opaque
stringData:
  POSTGRES_USER: userservice
  POSTGRES_PASSWORD: userpass123!
  POSTGRES_DB: users

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-users
  namespace: microservices
spec:
  serviceName: postgres-users
  replicas: 1
  selector:
    matchLabels:
      app: postgres-users
  template:
    metadata:
      labels:
        app: postgres-users
    spec:
      containers:
      - name: postgres
        image: postgres:14-alpine
        envFrom:
        - secretRef:
            name: postgres-users-secret
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
          subPath: postgres
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 5Gi

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-users
  namespace: microservices
spec:
  selector:
    app: postgres-users
  ports:
  - port: 5432
  clusterIP: None

---
# PostgreSQL for Product Service
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-products
  namespace: microservices
spec:
  serviceName: postgres-products
  replicas: 1
  selector:
    matchLabels:
      app: postgres-products
  template:
    metadata:
      labels:
        app: postgres-products
    spec:
      containers:
      - name: postgres
        image: postgres:14-alpine
        env:
        - name: POSTGRES_USER
          value: productservice
        - name: POSTGRES_PASSWORD
          value: productpass123!
        - name: POSTGRES_DB
          value: products
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
          subPath: postgres
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 5Gi

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-products
  namespace: microservices
spec:
  selector:
    app: postgres-products
  ports:
  - port: 5432
  clusterIP: None

---
# MongoDB for Orders
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: microservices
spec:
  serviceName: mongodb
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:5.0
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          value: admin
        - name: MONGO_INITDB_ROOT_PASSWORD
          value: mongopass123!
        - name: MONGO_INITDB_DATABASE
          value: orders
        ports:
        - containerPort: 27017
        volumeMounts:
        - name: mongo-storage
          mountPath: /data/db
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
  volumeClaimTemplates:
  - metadata:
      name: mongo-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: mongodb
  namespace: microservices
spec:
  selector:
    app: mongodb
  ports:
  - port: 27017
  clusterIP: None

---
# Redis for Cart/Session
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: microservices
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        command: ["redis-server"]
        args: ["--requirepass", "redispass123!"]
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: microservices
spec:
  selector:
    app: redis
  ports:
  - port: 6379

---
# Kafka
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka
  namespace: microservices
spec:
  serviceName: kafka
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
      - name: kafka
        image: confluentinc/cp-kafka:7.0.1
        ports:
        - containerPort: 9092
        - containerPort: 19092
        env:
        - name: KAFKA_BROKER_ID
          value: "1"
        - name: KAFKA_ZOOKEEPER_CONNECT
          value: zookeeper:2181
        - name: KAFKA_ADVERTISED_LISTENERS
          value: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:19092
        - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
          value: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
        - name: KAFKA_INTER_BROKER_LISTENER_NAME
          value: PLAINTEXT
        - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
          value: "1"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: kafka
  namespace: microservices
spec:
  selector:
    app: kafka
  ports:
  - name: broker
    port: 9092
  clusterIP: None

---
# Zookeeper for Kafka
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zookeeper
  namespace: microservices
spec:
  replicas: 1
  selector:
    matchLabels:
      app: zookeeper
  template:
    metadata:
      labels:
        app: zookeeper
    spec:
      containers:
      - name: zookeeper
        image: confluentinc/cp-zookeeper:7.0.1
        ports:
        - containerPort: 2181
        env:
        - name: ZOOKEEPER_CLIENT_PORT
          value: "2181"
        - name: ZOOKEEPER_TICK_TIME
          value: "2000"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "250m"

---
apiVersion: v1
kind: Service
metadata:
  name: zookeeper
  namespace: microservices
spec:
  selector:
    app: zookeeper
  ports:
  - port: 2181

---
# Elasticsearch
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: elasticsearch
  namespace: microservices
spec:
  serviceName: elasticsearch
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
        ports:
        - containerPort: 9200
        - containerPort: 9300
        env:
        - name: discovery.type
          value: single-node
        - name: xpack.security.enabled
          value: "false"
        - name: ES_JAVA_OPTS
          value: "-Xms512m -Xmx512m"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"
        volumeMounts:
        - name: es-storage
          mountPath: /usr/share/elasticsearch/data
  volumeClaimTemplates:
  - metadata:
      name: es-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
  namespace: microservices
spec:
  selector:
    app: elasticsearch
  ports:
  - name: http
    port: 9200
  - name: transport
    port: 9300
  clusterIP: None

---
# ============================================
# Microservices
# ============================================

# User Service (Go)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
        version: v1
    spec:
      containers:
      - name: user-service
        image: golang:1.19-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          cat <<'EOF' > main.go
          package main
          import (
              "encoding/json"
              "fmt"
              "log"
              "net/http"
              "os"
          )
          
          type User struct {
              ID    string `json:"id"`
              Name  string `json:"name"`
              Email string `json:"email"`
          }
          
          func main() {
              http.HandleFunc("/api/users/health", healthHandler)
              http.HandleFunc("/api/users", usersHandler)
              http.HandleFunc("/api/users/login", loginHandler)
              
              port := os.Getenv("PORT")
              if port == "" {
                  port = "8080"
              }
              
              log.Printf("User Service starting on port %s", port)
              log.Fatal(http.ListenAndServe(":"+port, nil))
          }
          
          func healthHandler(w http.ResponseWriter, r *http.Request) {
              w.WriteHeader(http.StatusOK)
              json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
          }
          
          func usersHandler(w http.ResponseWriter, r *http.Request) {
              users := []User{
                  {ID: "1", Name: "John Doe", Email: "john@example.com"},
                  {ID: "2", Name: "Jane Smith", Email: "jane@example.com"},
              }
              json.NewEncoder(w).Encode(users)
          }
          
          func loginHandler(w http.ResponseWriter, r *http.Request) {
              token := map[string]string{
                  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                  "user_id": "1",
              }
              json.NewEncoder(w).Encode(token)
          }
          EOF
          go run main.go
        env:
        - name: PORT
          value: "8080"
        - name: DB_HOST
          value: postgres-users
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: postgres-users-secret
              key: POSTGRES_USER
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-users-secret
              key: POSTGRES_PASSWORD
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/users/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/users/health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: microservices
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080

---
# Product Service (Python)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: product-service
  template:
    metadata:
      labels:
        app: product-service
        version: v1
    spec:
      containers:
      - name: product-service
        image: python:3.9-slim
        command: ["/bin/bash"]
        args:
        - -c
        - |
          pip install flask elasticsearch
          cat <<'EOF' > app.py
          from flask import Flask, jsonify
          import os
          
          app = Flask(__name__)
          
          @app.route('/api/products/health')
          def health():
              return jsonify({"status": "healthy"})
          
          @app.route('/api/products')
          def get_products():
              products = [
                  {"id": "1", "name": "Laptop", "price": 999.99, "stock": 50},
                  {"id": "2", "name": "Phone", "price": 699.99, "stock": 100},
                  {"id": "3", "name": "Tablet", "price": 399.99, "stock": 75},
              ]
              return jsonify(products)
          
          @app.route('/api/products/<product_id>')
          def get_product(product_id):
              product = {"id": product_id, "name": "Laptop", "price": 999.99, "stock": 50}
              return jsonify(product)
          
          @app.route('/api/products/search/<query>')
          def search_products(query):
              results = [
                  {"id": "1", "name": "Laptop", "score": 0.95},
              ]
              return jsonify(results)
          
          if __name__ == '__main__':
              port = int(os.getenv('PORT', 8081))
              app.run(host='0.0.0.0', port=port)
          EOF
          python app.py
        env:
        - name: PORT
          value: "8081"
        - name: DB_HOST
          value: postgres-products
        - name: ES_HOST
          value: elasticsearch
        ports:
        - containerPort: 8081
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/products/health
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/products/health
            port: 8081
          initialDelaySeconds: 10
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: product-service
  namespace: microservices
spec:
  selector:
    app: product-service
  ports:
  - port: 8081
    targetPort: 8081

---
# Order Service (Java simulation with Node.js for simplicity)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
        version: v1
    spec:
      containers:
      - name: order-service
        image: node:16-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          npm install express mongodb
          cat <<'EOF' > server.js
          const express = require('express');
          const app = express();
          app.use(express.json());
          
          app.get('/api/orders/health', (req, res) => {
              res.json({ status: 'healthy' });
          });
          
          app.get('/api/orders', (req, res) => {
              const orders = [
                  { id: '1', userId: '1', total: 1699.98, status: 'pending' },
                  { id: '2', userId: '2', total: 399.99, status: 'shipped' }
              ];
              res.json(orders);
          });
          
          app.post('/api/orders', (req, res) => {
              const order = {
                  id: Date.now().toString(),
                  ...req.body,
                  status: 'pending',
                  createdAt: new Date()
              };
              res.status(201).json(order);
          });
          
          app.get('/api/orders/:id', (req, res) => {
              const order = {
                  id: req.params.id,
                  userId: '1',
                  items: [
                      { productId: '1', quantity: 1, price: 999.99 }
                  ],
                  total: 999.99,
                  status: 'pending'
              };
              res.json(order);
          });
          
          const PORT = process.env.PORT || 8082;
          app.listen(PORT, () => {
              console.log(`Order Service running on port ${PORT}`);
          });
          EOF
          node server.js
        env:
        - name: PORT
          value: "8082"
        - name: MONGO_URL
          value: mongodb://admin:mongopass123!@mongodb:27017/orders
        - name: KAFKA_BROKER
          value: kafka:9092
        ports:
        - containerPort: 8082
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"
        livenessProbe:
          httpGet:
            path: /api/orders/health
            port: 8082
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/orders/health
            port: 8082
          initialDelaySeconds: 10
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: order-service
  namespace: microservices
spec:
  selector:
    app: order-service
  ports:
  - port: 8082
    targetPort: 8082

---
# Cart Service (Node.js)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cart-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: cart-service
  template:
    metadata:
      labels:
        app: cart-service
        version: v1
    spec:
      containers:
      - name: cart-service
        image: node:16-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          npm install express redis
          cat <<'EOF' > server.js
          const express = require('express');
          const app = express();
          app.use(express.json());
          
          app.get('/api/cart/health', (req, res) => {
              res.json({ status: 'healthy' });
          });
          
          app.get('/api/cart/:userId', (req, res) => {
              const cart = {
                  userId: req.params.userId,
                  items: [
                      { productId: '1', quantity: 1, price: 999.99 },
                      { productId: '3', quantity: 2, price: 399.99 }
                  ],
                  total: 1799.97
              };
              res.json(cart);
          });
          
          app.post('/api/cart/:userId/items', (req, res) => {
              res.json({ success: true, message: 'Item added to cart' });
          });
          
          app.delete('/api/cart/:userId/items/:productId', (req, res) => {
              res.json({ success: true, message: 'Item removed from cart' });
          });
          
          const PORT = process.env.PORT || 8083;
          app.listen(PORT, () => {
              console.log(`Cart Service running on port ${PORT}`);
          });
          EOF
          node server.js
        env:
        - name: PORT
          value: "8083"
        - name: REDIS_HOST
          value: redis
        - name: REDIS_PASSWORD
          value: redispass123!
        ports:
        - containerPort: 8083
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/cart/health
            port: 8083
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/cart/health
            port: 8083
          initialDelaySeconds: 10
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: cart-service
  namespace: microservices
spec:
  selector:
    app: cart-service
  ports:
  - port: 8083
    targetPort: 8083

---
# Payment Service (Go)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: payment-service
  template:
    metadata:
      labels:
        app: payment-service
        version: v1
    spec:
      containers:
      - name: payment-service
        image: golang:1.19-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          cat <<'EOF' > main.go
          package main
          import (
              "encoding/json"
              "log"
              "net/http"
              "os"
          )
          
          type PaymentRequest struct {
              OrderID string  `json:"orderId"`
              Amount  float64 `json:"amount"`
              Method  string  `json:"method"`
          }
          
          func main() {
              http.HandleFunc("/api/payments/health", healthHandler)
              http.HandleFunc("/api/payments/process", processPayment)
              http.HandleFunc("/api/payments/status", paymentStatus)
              
              port := os.Getenv("PORT")
              if port == "" {
                  port = "8084"
              }
              
              log.Printf("Payment Service starting on port %s", port)
              log.Fatal(http.ListenAndServe(":"+port, nil))
          }
          
          func healthHandler(w http.ResponseWriter, r *http.Request) {
              w.WriteHeader(http.StatusOK)
              json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
          }
          
          func processPayment(w http.ResponseWriter, r *http.Request) {
              result := map[string]interface{}{
                  "transactionId": "TXN-" + "123456",
                  "status": "approved",
                  "message": "Payment processed successfully",
              }
              json.NewEncoder(w).Encode(result)
          }
          
          func paymentStatus(w http.ResponseWriter, r *http.Request) {
              status := map[string]string{
                  "transactionId": r.URL.Query().Get("txn"),
                  "status": "completed",
              }
              json.NewEncoder(w).Encode(status)
          }
          EOF
          go run main.go
        env:
        - name: PORT
          value: "8084"
        - name: KAFKA_BROKER
          value: kafka:9092
        ports:
        - containerPort: 8084
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/payments/health
            port: 8084
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/payments/health
            port: 8084
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: payment-service
  namespace: microservices
spec:
  selector:
    app: payment-service
  ports:
  - port: 8084
    targetPort: 8084

---
# API Gateway
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
        version: v1
    spec:
      containers:
      - name: api-gateway
        image: node:16-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          npm install express http-proxy-middleware cors
          cat <<'EOF' > gateway.js
          const express = require('express');
          const { createProxyMiddleware } = require('http-proxy-middleware');
          const cors = require('cors');
          
          const app = express();
          app.use(cors());
          app.use(express.json());
          
          // Health check
          app.get('/health', (req, res) => {
              res.json({ status: 'healthy', service: 'api-gateway' });
          });
          
          // Service routes
          const services = {
              '/api/users': 'http://user-service:8080',
              '/api/products': 'http://product-service:8081',
              '/api/orders': 'http://order-service:8082',
              '/api/cart': 'http://cart-service:8083',
              '/api/payments': 'http://payment-service:8084'
          };
          
          Object.keys(services).forEach(path => {
              app.use(path, createProxyMiddleware({
                  target: services[path],
                  changeOrigin: true,
                  onError: (err, req, res) => {
                      console.error(`Error proxying ${path}:`, err);
                      res.status(503).json({ error: 'Service temporarily unavailable' });
                  }
              }));
          });
          
          const PORT = process.env.PORT || 8000;
          app.listen(PORT, () => {
              console.log(`API Gateway running on port ${PORT}`);
          });
          EOF
          node gateway.js
        env:
        - name: PORT
          value: "8000"
        ports:
        - containerPort: 8000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway
  namespace: microservices
spec:
  type: LoadBalancer
  selector:
    app: api-gateway
  ports:
  - port: 80
    targetPort: 8000

---
# Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: microservices-ingress
  namespace: microservices
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  rules:
  - host: microservices.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway
            port:
              number: 80

---
# HorizontalPodAutoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-gateway-hpa
  namespace: microservices
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-gateway
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80